{"version":3,"file":"execCommand.js","sourceRoot":"","sources":["../../src/template-filters/execCommand.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAC1B,wDAA+B;AAE/B,oCAAqE;AAErE,qEAAqE;AACrE,MAAM,YAAY,GAAG,qBAAa,CAAC,GAAG,EAAE,CACpC,IAAI,OAAO,CAAyB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CACpD,kBAAO,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;IACzB,IAAI,KAAK,EAAE;QACP,MAAM,CAAC,KAAK,CAAC,CAAC;KACjB;SAAM,IAAI,KAAK,EAAE;QACd,OAAO,CAAC,EAAE,CAAC,kBAAO,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;KACtC;SAAM;QACH,OAAO,CAAC,EAAE,CAAC,CAAC;KACf;AACL,CAAC,CAAC,CACL,CACJ,CAAC;AAEK,KAAK,UAAU,WAAW,CAAC,OAAgB;;IAC9C,MAAM,OAAO,GAAkB;QAC3B,GAAG,EAAE,IAAI;QACT,GAAG,EAAE,MAAM,YAAY,EAAE;KAC5B,CAAC;IACF,IAAI,IAAyC,CAAC;IAC9C,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC7B,IAAI,GAAG,eAAK,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;KAC1C;SAAM,IAAI,qBAAa,CAAC,OAAO,CAAC,EAAE;QAC/B,MAAM,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,OAAO,CAAC;QAChC,IAAI,GAAG,eAAK,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,IAAI,EAAE;QACP,MAAM,IAAI,SAAS,CAAC,mBAAW,CAAA,0BAA0B,OAAO,EAAE,CAAC,CAAC;KACvE;IAED,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC;IAC1B,aAAO,MAAM,CAAC,GAAG,mCAAI,MAAM,CAAC,MAAM,CAAC;AACvC,CAAC;AAlBD,kCAkBC","sourcesContent":["import execa from 'execa';\nimport npmPath from 'npm-path';\n\nimport { cachedPromise, errorMsgTag, isStringArray } from '../utils';\n\n// eslint-disable-next-line @typescript-eslint/promise-function-async\nconst getEnvRecord = cachedPromise(() =>\n    new Promise<Record<string, string>>((resolve, reject) =>\n        npmPath.get((error, $PATH) => {\n            if (error) {\n                reject(error);\n            } else if ($PATH) {\n                resolve({ [npmPath.PATH]: $PATH });\n            } else {\n                resolve({});\n            }\n        })\n    )\n);\n\nexport async function execCommand(command: unknown): Promise<string> {\n    const options: execa.Options = {\n        all: true,\n        env: await getEnvRecord(),\n    };\n    let proc: execa.ExecaChildProcess | undefined;\n    if (typeof command === 'string') {\n        proc = execa.command(command, options);\n    } else if (isStringArray(command)) {\n        const [file, ...args] = command;\n        proc = execa(file, args, options);\n    }\n    if (!proc) {\n        throw new TypeError(errorMsgTag`Invalid command value: ${command}`);\n    }\n\n    const result = await proc;\n    return result.all ?? result.stdout;\n}\n"]}