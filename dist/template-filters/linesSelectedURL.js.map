{"version":3,"file":"linesSelectedURL.js","sourceRoot":"","sources":["../../src/template-filters/linesSelectedURL.ts"],"names":[],"mappings":";;;AAAA,+BAA8C;AAI9C,oCAAmD;AACnD,gDAAgD;AAahD,SAAS,UAAU,CACf,YAAoB,EACpB,EAAE,QAAQ,GAAG,EAAE,EAAE,WAAW,GAAG,EAAE,KAAkD,EAAE;IAErF,OAAO,IAAI,MAAM,CACb,YAAY,CAAC,MAAM,EACnB,CACI,YAAY,CAAC,KAAK;SACb,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CACrE,GAAG,QAAQ,CACf,CAAC;AACN,CAAC;AAED,SAAS,gBAAgB,CAAC,IAAY;IAClC,MAAM,eAAe,GAAG,WAAW,CAAC;IACpC,MAAM,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7B,KAAK,IAAI,KAAK,EAAE,CAAC,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG;QACnD,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;KACxD;IACD,OAAO,gBAAgB,CAAC;AAC5B,CAAC;AAED,SAAS,cAAc,CAAC,gBAAmC,EAAE,MAAc;IACvE,OAAO,CACH,gBAAgB,CAAC,SAAS,CAAC,CAAC,YAAY,EAAE,KAAK,EAAE,EAAE;;QAC/C,MAAM,gBAAgB,SAAG,gBAAgB,CAAC,KAAK,GAAG,CAAC,CAAC,mCAAI,QAAQ,CAAC;QACjE,OAAO,YAAY,IAAI,MAAM,IAAI,MAAM,GAAG,gBAAgB,CAAC;IAC/D,CAAC,CAAC,CACL,GAAG,CAAC,CAAC;AACV,CAAC;AAED,SAAS,UAAU,CAAC,KAAc;IAC9B,OAAO,CACH,gBAAQ,CAAC,KAAK,CAAC;WACZ,OAAO,KAAK,CAAC,QAAQ,KAAK,QAAQ;WAClC,OAAO,KAAK,CAAC,YAAY,KAAK,QAAQ;WACtC,OAAO,KAAK,CAAC,SAAS,KAAK,QAAQ,CACzC,CAAC;AACN,CAAC;AAED,SAAS,SAAS,CAAC,KAAc;IAC7B,OAAO,CACH,gBAAQ,CAAC,KAAK,CAAC;WACZ,KAAK,CAAC,KAAK,YAAY,MAAM;WAC7B,CAAC,KAAK,CAAC,GAAG,YAAY,MAAM,IAAI,KAAK,CAAC,GAAG,KAAK,SAAS,CAAC,CAC9D,CAAC;AACN,CAAC;AAED,MAAM,UAAU,GAAG,IAAI,GAAG,EAA2D,CAAC;AAEtF,SAAgB,mBAAmB,CAAC,EAAE,eAAe,EAA+C;IAChG,OAAO,KAAK,UAAU,gBAAgB,CAAC,QAAiB,EAAE,OAAgB;QACtE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YACvB,MAAM,IAAI,SAAS,CAAC,sBAAW,CAAA,2BAA2B,QAAQ,EAAE,CAAC,CAAC;SACzE;QACD,IAAI,CAAC,CAAC,OAAO,YAAY,MAAM,IAAI,SAAS,CAAC,OAAO,CAAC,CAAC,EAAE;YACpD,MAAM,IAAI,SAAS,CAAC,sBAAW,CAAA,0BAA0B,OAAO,EAAE,CAAC,CAAC;SACvE;QACD,MAAM,eAAe,GAAG,UAAU,CAC9B,OAAO,YAAY,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EACnD,EAAE,WAAW,EAAE,IAAI,EAAE,CACxB,CAAC;QACF,MAAM,aAAa,GAAG,OAAO,YAAY,MAAM;YAC3C,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC;QACpE,MAAM,eAAe,GAAG,OAAO,YAAY,MAAM,CAAC;QAElD,MAAM,YAAY,GAAG,cAAW,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QACxD,IAAI,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC5C,IAAI,CAAC,QAAQ,EAAE;YACX,MAAM,WAAW,GAAG,MAAM,qBAAa,CAAC,eAAe,CAAC,YAAY,CAAC,EAAE,MAAM,CAAC,CAAC;YAC/E,QAAQ,GAAG;gBACP,OAAO,EAAE,WAAW;gBACpB,gBAAgB,EAAE,gBAAgB,CAAC,WAAW,CAAC;aAClD,CAAC;SACL;QACD,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,GAAG,QAAQ,CAAC;QAE5D,MAAM,CAAC,eAAe,EAAE,aAAa,CAAC,GAAG,gBAAgB,CAAC,MAAM,CAC5D,CACI,CAAC,eAAe,EAAE,aAAa,EAAE,UAAU,CAAC,EAC5C,YAAY,EACZ,KAAK,EACP,EAAE;YACA,MAAM,iBAAiB,GAAG,KAAK,GAAG,CAAC,CAAC;YACpC,MAAM,sBAAsB,GAAG,CAAC,eAAe;mBACxC,CAAC,CAAC,eAAe,CAAC,SAAS,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACzD,MAAM,oBAAoB,GAAG,aAAa;mBACnC,CAAC,aAAa;mBACd,CAAC,CAAC,aAAa,CAAC,SAAS,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAErD,IAAI,sBAAsB,IAAI,oBAAoB,EAAE;gBAChD,MAAM,IAAI,GAAG,WAAW,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;gBAEjD,IAAI,sBAAsB,EAAE;oBACxB,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACzC,UAAU,CAAC,KAAK,GAAG,IAAI,CAAC;oBAExB,IAAI,KAAK,EAAE;wBACP,MAAM,aAAa,GAAG,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC;wBACjD,MAAM,WAAW,GAAG,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;wBACpD,IAAI,eAAe,EAAE;4BACjB,eAAe,GAAG,cAAc,CAAC,gBAAgB,EAAE,aAAa,CAAC,CAAC;4BAClE,aAAa,GAAG,cAAc,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;yBACjE;6BAAM;4BACH,eAAe,GAAG,cAAc,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;yBACnE;qBACJ;iBACJ;gBACD,IACI,aAAa;uBACV,oBAAoB;uBACpB,eAAe;uBACf,eAAe,IAAI,iBAAiB,EACzC;oBACE,MAAM,KAAK,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACvC,UAAU,CAAC,GAAG,GAAG,IAAI,CAAC;oBAEtB,IAAI,KAAK,EAAE;wBACP,MAAM,WAAW,GAAG,YAAY,GAAG,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;wBACjE,aAAa,GAAG,cAAc,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;qBACjE;iBACJ;aACJ;YAED,OAAO,CAAC,eAAe,EAAE,aAAa,EAAE,UAAU,CAAC,CAAC;QACxD,CAAC,EACD,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,CACvC,CAAC;QACF,IAAI,CAAC,eAAe,EAAE;YAClB,MAAM,IAAI,KAAK,CACX,sBAAW,CAAA,8BACP,eAAe,CAAC,YAAY,CAChC,gDAAgD;kBAC1C,CAAC,OAAO,YAAY,MAAM;oBACxB,CAAC,CAAC,sBAAW,CAAA,kBAAkB,eAAe,EAAE;oBAChD,CAAC,CAAC,sBAAW,CAAA,gCAAgC,eAAe,EAAE,CAAC,CAC1E,CAAC;SACL;QACD,IAAI,aAAa,IAAI,CAAC,aAAa,EAAE;YACjC,MAAM,IAAI,KAAK,CACX,sBAAW,CAAA,8BAA8B,eAAe,CAAC,YAAY,CAAC,YAAY;kBAC5E,sBAAW,CAAA,kEAAkE,aAAa,EAAE,CACrG,CAAC;SACL;QAED,IAAI,eAAe,CAAC;QACpB,MAAM,WAAW,GAAG,aAAa,IAAI,eAAe,KAAK,aAAa,CAAC;QACvE,IAAI,QAAQ,CAAC,QAAQ,KAAK,QAAQ,EAAE;YAChC,eAAe,GAAG,WAAW;gBACzB,CAAC,CAAC,KAAK,eAAe,KAAK,aAAa,EAAE;gBAC1C,CAAC,CAAC,KAAK,eAAe,EAAE,CAAC;SAChC;aAAM,IAAI,QAAQ,CAAC,QAAQ,KAAK,QAAQ,EAAE;YACvC,eAAe,GAAG,WAAW;gBACzB,CAAC,CAAC,KAAK,eAAe,IAAI,aAAa,EAAE;gBACzC,CAAC,CAAC,KAAK,eAAe,EAAE,CAAC;SAChC;aAAM,IAAI,QAAQ,CAAC,QAAQ,KAAK,WAAW,EAAE;YAC1C,eAAe,GAAG,WAAW;gBACzB,CAAC,CAAC,UAAU,eAAe,IAAI,aAAa,EAAE;gBAC9C,CAAC,CAAC,UAAU,eAAe,EAAE,CAAC;SACrC;aAAM,IAAI,QAAQ,CAAC,QAAQ,KAAK,MAAM,EAAE;YACrC,eAAe,GAAG,WAAW;gBACzB,CAAC,CAAC,KAAK,eAAe,KAAK,aAAa,EAAE;gBAC1C,CAAC,CAAC,KAAK,eAAe,EAAE,CAAC;SAChC;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,sBAAW,CAAA,oCAAoC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;SACvF;QAED,OAAO,QAAQ,CAAC,SAAS,GAAG,eAAe,CAAC;IAChD,CAAC,CAAC;AACN,CAAC;AAxHD,kDAwHC","sourcesContent":["import { resolve as resolvePath } from 'path';\n\nimport type hostedGitInfo from 'hosted-git-info';\n\nimport { isObject, readFileAsync } from '../utils';\nimport { errorMsgTag } from '../utils/nunjucks';\n\nexport interface RepoData {\n    repoType: hostedGitInfo.Hosts;\n    fileFullpath: string;\n    browseURL: string;\n}\n\ninterface Options {\n    start: RegExp;\n    end?: RegExp;\n}\n\nfunction copyRegExp(\n    sourceRegExp: RegExp,\n    { addFlags = '', deleteFlags = '' }: { addFlags?: string; deleteFlags?: string } = {},\n): RegExp {\n    return new RegExp(\n        sourceRegExp.source,\n        (\n            sourceRegExp.flags\n                .replace(/./g, char => deleteFlags.includes(char) ? '' : char)\n        ) + addFlags,\n    );\n}\n\nfunction getLinesStartPos(text: string): number[] {\n    const lineBreakRegExp = /\\r\\n?|\\n/g;\n    const lineStartPosList = [0];\n    for (let match; (match = lineBreakRegExp.exec(text));) {\n        lineStartPosList.push(match.index + match[0].length);\n    }\n    return lineStartPosList;\n}\n\nfunction strPos2lineNum(lineStartPosList: readonly number[], strPos: number): number {\n    return (\n        lineStartPosList.findIndex((lineStartPos, index) => {\n            const nextLineStartPos = lineStartPosList[index + 1] ?? Infinity;\n            return lineStartPos <= strPos && strPos < nextLineStartPos;\n        })\n    ) + 1;\n}\n\nfunction isRepoData(value: unknown): value is RepoData {\n    return (\n        isObject(value)\n        && typeof value.repoType === 'string'\n        && typeof value.fileFullpath === 'string'\n        && typeof value.browseURL === 'string'\n    );\n}\n\nfunction isOptions(value: unknown): value is Options {\n    return (\n        isObject(value)\n        && value.start instanceof RegExp\n        && (value.end instanceof RegExp || value.end === undefined)\n    );\n}\n\nconst cacheStore = new Map<string, { content: string; lineStartPosList: number[] }>();\n\nexport function linesSelectedURLGen({ cwdRelativePath }: { cwdRelativePath: (to: string) => string }) {\n    return async function linesSelectedURL(repoData: unknown, options: unknown): Promise<string> {\n        if (!isRepoData(repoData)) {\n            throw new TypeError(errorMsgTag`Invalid repoData value: ${repoData}`);\n        }\n        if (!(options instanceof RegExp || isOptions(options))) {\n            throw new TypeError(errorMsgTag`Invalid options value: ${options}`);\n        }\n        const startLineRegExp = copyRegExp(\n            options instanceof RegExp ? options : options.start,\n            { deleteFlags: 'gy' },\n        );\n        const endLineRegExp = options instanceof RegExp\n            ? null\n            : options.end && copyRegExp(options.end, { deleteFlags: 'gy' });\n        const isFullMatchMode = options instanceof RegExp;\n\n        const fileFullpath = resolvePath(repoData.fileFullpath);\n        let fileData = cacheStore.get(fileFullpath);\n        if (!fileData) {\n            const fileContent = await readFileAsync(cwdRelativePath(fileFullpath), 'utf8');\n            fileData = {\n                content: fileContent,\n                lineStartPosList: getLinesStartPos(fileContent),\n            };\n        }\n        const { content: fileContent, lineStartPosList } = fileData;\n\n        const [startLineNumber, endLineNumber] = lineStartPosList.reduce(\n            (\n                [startLineNumber, endLineNumber, triedMatch],\n                lineStartPos,\n                index,\n            ) => {\n                const currentLineNumber = index + 1;\n                const isTryStartLineMatching = !startLineNumber\n                    && (!startLineRegExp.multiline || !triedMatch.start);\n                const isTryEndLineMatching = endLineRegExp\n                    && !endLineNumber\n                    && (!endLineRegExp.multiline || !triedMatch.end);\n\n                if (isTryStartLineMatching || isTryEndLineMatching) {\n                    const text = fileContent.substring(lineStartPos);\n\n                    if (isTryStartLineMatching) {\n                        const match = startLineRegExp.exec(text);\n                        triedMatch.start = true;\n\n                        if (match) {\n                            const matchStartPos = lineStartPos + match.index;\n                            const matchEndPos = matchStartPos + match[0].length;\n                            if (isFullMatchMode) {\n                                startLineNumber = strPos2lineNum(lineStartPosList, matchStartPos);\n                                endLineNumber = strPos2lineNum(lineStartPosList, matchEndPos);\n                            } else {\n                                startLineNumber = strPos2lineNum(lineStartPosList, matchEndPos);\n                            }\n                        }\n                    }\n                    if (\n                        endLineRegExp\n                        && isTryEndLineMatching\n                        && startLineNumber\n                        && startLineNumber <= currentLineNumber\n                    ) {\n                        const match = endLineRegExp.exec(text);\n                        triedMatch.end = true;\n\n                        if (match) {\n                            const matchEndPos = lineStartPos + match.index + match[0].length;\n                            endLineNumber = strPos2lineNum(lineStartPosList, matchEndPos);\n                        }\n                    }\n                }\n\n                return [startLineNumber, endLineNumber, triedMatch];\n            },\n            [0, 0, { start: false, end: false }],\n        );\n        if (!startLineNumber) {\n            throw new Error(\n                errorMsgTag`RegExp does not match with ${\n                    cwdRelativePath(fileFullpath)\n                } contents. The following pattern was passed in`\n                    + (options instanceof RegExp\n                        ? errorMsgTag` the argument: ${startLineRegExp}`\n                        : errorMsgTag` the options.start argument: ${startLineRegExp}`),\n            );\n        }\n        if (endLineRegExp && !endLineNumber) {\n            throw new Error(\n                errorMsgTag`RegExp does not match with ${cwdRelativePath(fileFullpath)} contents.`\n                    + errorMsgTag` The following pattern was passed in the options.end argument: ${endLineRegExp}`,\n            );\n        }\n\n        let browseURLSuffix;\n        const isMultiLine = endLineNumber && startLineNumber !== endLineNumber;\n        if (repoData.repoType === 'github') {\n            browseURLSuffix = isMultiLine\n                ? `#L${startLineNumber}-L${endLineNumber}`\n                : `#L${startLineNumber}`;\n        } else if (repoData.repoType === 'gitlab') {\n            browseURLSuffix = isMultiLine\n                ? `#L${startLineNumber}-${endLineNumber}`\n                : `#L${startLineNumber}`;\n        } else if (repoData.repoType === 'bitbucket') {\n            browseURLSuffix = isMultiLine\n                ? `#lines-${startLineNumber}:${endLineNumber}`\n                : `#lines-${startLineNumber}`;\n        } else if (repoData.repoType === 'gist') {\n            browseURLSuffix = isMultiLine\n                ? `-L${startLineNumber}-L${endLineNumber}`\n                : `-L${startLineNumber}`;\n        } else {\n            throw new Error(errorMsgTag`Unknown repoData.repoType value: ${repoData.repoType}`);\n        }\n\n        return repoData.browseURL + browseURLSuffix;\n    };\n}\n"]}